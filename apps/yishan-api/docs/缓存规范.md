# 缓存规范

本文档定义系统内关于“用户详情”场景的缓存策略、键命名规则、TTL 配置与一致性处理，确保接口行为可预期、实现可维护。

## 适用范围
- 接口：`GET /api/v1/admin/user/:id`、`POST /api/v1/admin/user`、`PUT /api/v1/admin/user/:id`、`DELETE /api/v1/admin/user/:id`
- 缓存对象：用户详情（接口返回的用户实体数据，非敏感信息）

## 依赖与降级
- 依赖：Redis（通过 `fastify.redis` 提供）。
- 降级：若 Redis 未启用或发生异常，接口直接访问数据库，不影响业务响应；缓存操作失败仅记录 warn 日志。

## 键命名与 TTL
- 键命名：`user:detail:{userId}`，例如用户 ID 为 `42` 时，键为 `user:detail:42`。
- TTL 策略：
  - 全局默认 TTL：`CACHE_TTL_DEFAULT`（秒），默认 `300`。
  - 用户详情 TTL：`CACHE_TTL_USER_DETAIL`（秒），优先于 `USER_DETAIL_CACHE_TTL`（旧变量，向后兼容）。未设置时回退到 `CACHE_TTL_DEFAULT`。

## 读写策略
- 查询详情：`GET /api/v1/admin/user/:id`
  - 先读缓存：命中则直接返回。
  - 未命中：查询数据库，并将结果以 TTL 写入缓存。
- 创建用户：`POST /api/v1/admin/user`
  - 创建成功后，将创建结果写入详情缓存（键为新用户的 ID）。
- 更新用户：`PUT /api/v1/admin/user/:id`
  - 更新成功后，同步刷新详情缓存（覆盖为最新用户数据）。
- 删除用户：`DELETE /api/v1/admin/user/:id`
  - 删除成功后，删除对应的详情缓存键。

## 数据格式
- 使用 JSON 字符串存储（`JSON.stringify(user)`），读取时使用 `JSON.parse`。
- 缓存的数据以接口返回的用户实体为准，避免包含敏感字段（如密码哈希）。

## 一致性与并发
- TTL 控制过期；创建/更新操作使用覆盖写入，删除操作直接 `DEL`。
- 缓存失败不影响主流程；日志级别为 warn，便于观测与定位。

## 代码约定
- 在配置中心集中管理 TTL：`CACHE_CONFIG`。
  - `CACHE_CONFIG.defaultTTLSeconds`：全局默认 TTL。
  - `CACHE_CONFIG.userDetailTTLSeconds`：用户详情 TTL。
- 在路由模块顶部仅定义键生成方法：`getUserDetailCacheKey(userId: number)`。
- 所有路由优先使用 `CACHE_CONFIG` 提供的 TTL，避免散落的硬编码与不一致。

## 环境变量
- `CACHE_TTL_DEFAULT`：全局默认 TTL（秒），默认 `300`。
- `CACHE_TTL_USER_DETAIL`：用户详情 TTL（秒），默认 `300`；未设置时回退到全局默认。
- `USER_DETAIL_CACHE_TTL`：旧变量，保留向后兼容（若设置将被读取为用户详情 TTL）。

## 示例
- 键示例：`user:detail:42`
- TTL 示例：`300`

## 后续扩展
- 可根据业务需要扩展到列表缓存、热点预热、淘汰策略、批量失效等场景，保持键命名与 TTL 的集中管理。