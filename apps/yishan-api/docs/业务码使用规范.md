# 业务码使用规范

## 概述

本文档描述了项目中业务码的设计规范、使用方法和最佳实践。业务码系统采用模块化设计，便于维护和扩展。

## 目录结构

```
src/constants/business-codes/
├── index.ts          # 统一导出和管理
├── common.ts         # 通用业务码（成功码、系统错误）
├── validation.ts     # 参数验证相关
├── auth.ts          # 认证授权相关
├── user.ts          # 用户模块相关
├── resource.ts      # 资源操作相关
└── business.ts      # 业务逻辑相关

src/constants/
└── business-code.ts  # 向后兼容文件（已废弃）
```

## 业务码分类和范围

### 1. 成功码
- **10000**: 操作成功

### 2. 系统错误码 (20xxx)
- **20001**: 系统内部错误
- **20002**: 数据库操作失败
- **20003**: 网络连接失败
- **20004**: 请求过于频繁
- **20005**: 服务不可用

### 3. 参数验证错误码 (21xxx)
- **21001**: 参数无效
- **21002**: 参数缺失
- **21003**: 参数格式错误
- **21004**: 参数长度超限
- **21005**: 数据验证失败

### 4. 认证授权错误码 (22xxx)
- **22001**: 未授权访问
- **22002**: 访问被禁止
- **22003**: Token已过期
- **22004**: Token无效
- **22005**: 权限不足

### 5. 用户模块错误码 (30xxx)
- **30001**: 用户不存在
- **30002**: 用户已存在
- **30003**: 用户状态异常
- **30004**: 密码错误
- **30005**: 用户被禁用

### 6. 资源操作错误码 (31xxx)
- **31001**: 资源不存在
- **31002**: 资源已存在
- **31003**: 资源访问被拒绝
- **31004**: 资源状态异常
- **31005**: 资源操作失败

### 7. 业务逻辑错误码 (32xxx)
- **32001**: 业务规则违反
- **32002**: 操作不被允许
- **32003**: 状态转换无效
- **32004**: 业务数据异常
- **32005**: 业务流程错误

## 使用方法

### 1. 导入业务码

#### 推荐方式（模块化导入）
```typescript
// 导入特定模块的错误码
import { UserErrorCode } from '../constants/business-codes/user.js'
import { ValidationErrorCode } from '../constants/business-codes/validation.js'
import { AuthErrorCode } from '../constants/business-codes/auth.js'

// 或者从统一入口导入
import { 
  UserErrorCode, 
  ValidationErrorCode, 
  AuthErrorCode,
  SUCCESS_CODE,
  BusinessCode 
} from '../constants/business-codes/index.js'
```

#### 兼容方式（不推荐）
```typescript
// 向后兼容，但已标记为废弃
import { ErrorCode } from '../constants/business-code.js'
```

### 2. 使用错误码

```typescript
// 在服务层抛出错误
if (!user) {
  throw new Error(`${UserErrorCode.USER_NOT_FOUND}`)
}

if (existingUser) {
  throw new Error(`${UserErrorCode.USER_ALREADY_EXISTS}`)
}

// 在路由层返回错误响应
if (!userId) {
  return ResponseUtil.error(
    reply, 
    ValidationErrorCode.INVALID_PARAMETER, 
    '用户ID不能为空'
  )
}
```

### 3. 使用BusinessCode工具类

```typescript
import { BusinessCode } from '../constants/business-codes/index.js'

// 获取错误消息
const message = BusinessCode.getMessage(UserErrorCode.USER_NOT_FOUND)

// 获取HTTP状态码（智能映射）
const httpStatus = BusinessCode.getHttpStatus(AuthErrorCode.UNAUTHORIZED) // 返回 401
const businessStatus = BusinessCode.getHttpStatus(UserErrorCode.USER_NOT_FOUND) // 返回 200

// 获取错误类型
const errorType = BusinessCode.getErrorType(ValidationErrorCode.INVALID_PARAMETER)

// 验证业务码是否有效
const isValid = BusinessCode.isValidCode(30001) // 检查业务码是否在系统中定义

// 判断是否为成功码
const isSuccess = BusinessCode.isSuccess(10000) // true

// 判断是否为错误码
const isError = BusinessCode.isError(30001) // true
```

## 最佳实践

### 1. 错误码选择原则
- 根据错误的性质选择合适的模块错误码
- 优先使用已定义的错误码，避免重复定义
- 新增错误码时遵循现有的编号规则

### 2. 错误消息规范
- 错误消息应该简洁明了，便于用户理解
- 避免暴露系统内部实现细节
- 支持国际化的错误消息

### 3. HTTP状态码映射
- 每个业务码都有对应的HTTP状态码
- 遵循RESTful API的状态码约定
- 客户端可以根据HTTP状态码进行通用错误处理

#### HTTP状态码映射规则

系统采用智能的HTTP状态码映射策略，根据业务码的范围自动确定合适的HTTP状态码：

| 业务码范围 | 错误类型 | HTTP状态码 | 说明 |
|-----------|---------|-----------|------|
| 10000 | 成功码 | 200 | 操作成功 |
| 20000-20999 | 系统错误 | 500 | 服务器内部错误 |
| 21000-21999 | 参数验证错误 | 400 | 客户端请求错误 |
| 22000-22999 | 认证授权错误 | 401 | 未授权错误 |
| 30000-30999 | 用户模块错误 | 200 | 业务错误，正常响应 |
| 31000-31999 | 资源操作错误 | 200 | 业务错误，正常响应 |
| 32000-32999 | 业务逻辑错误 | 200 | 业务错误，正常响应 |

**重要说明**：
- **系统级错误** (20xxx-22xxx)：返回对应的HTTP错误状态码，表示请求处理过程中的技术问题
- **业务级错误** (30xxx及以上)：统一返回HTTP 200，错误信息通过响应体中的业务码传递
- 这种设计遵循了"HTTP状态码表示传输层状态，业务码表示业务层状态"的原则
- 前端可以统一处理HTTP 200的响应，通过业务码判断具体的业务结果

#### 映射优先级

1. **直接映射**：优先查找预定义的HTTP状态码映射表
2. **范围映射**：根据业务码范围确定默认HTTP状态码
3. **兜底策略**：未知错误码默认返回500

### 4. 错误处理流程
1. **服务层**: 抛出带有业务码的错误
2. **全局错误处理器**: 捕获错误并转换为统一响应格式
3. **客户端**: 根据业务码进行具体的错误处理

## 扩展指南

### 添加新的错误码模块

1. 在 `src/constants/business-codes/` 目录下创建新的模块文件
2. 定义错误码枚举、错误消息和HTTP状态码映射
3. 在 `index.ts` 中导出新模块的类型和常量
4. 更新本文档的分类说明

### 示例：添加订单模块错误码

```typescript
// src/constants/business-codes/order.ts
export enum OrderErrorCode {
  ORDER_NOT_FOUND = 33001,
  ORDER_STATUS_INVALID = 33002,
  ORDER_CANNOT_CANCEL = 33003,
  // ...
}

export const OrderErrorMessages = {
  [OrderErrorCode.ORDER_NOT_FOUND]: '订单不存在',
  [OrderErrorCode.ORDER_STATUS_INVALID]: '订单状态无效',
  [OrderErrorCode.ORDER_CANNOT_CANCEL]: '订单无法取消',
  // ...
} as const

export const OrderHttpStatusMap = {
  [OrderErrorCode.ORDER_NOT_FOUND]: 404,
  [OrderErrorCode.ORDER_STATUS_INVALID]: 400,
  [OrderErrorCode.ORDER_CANNOT_CANCEL]: 409,
  // ...
} as const

export type OrderErrorCodeType = keyof typeof OrderErrorCode
```

## 迁移指南

### 从旧版本迁移

1. **更新导入语句**
   ```typescript
   // 旧版本
   import { ErrorCode } from '../constants/business-code.js'
   
   // 新版本
   import { UserErrorCode } from '../constants/business-codes/user.js'
   ```

2. **更新错误码引用**
   ```typescript
   // 旧版本
   ErrorCode.USER_NOT_FOUND
   
   // 新版本
   UserErrorCode.USER_NOT_FOUND
   ```

3. **批量替换工具**
   可以使用IDE的查找替换功能进行批量迁移，建议按模块逐步迁移。

## 注意事项

1. **向后兼容性**: 旧的 `business-code.ts` 文件仍然可用，但建议迁移到新的模块化结构
2. **类型安全**: 新的模块化设计提供了更好的TypeScript类型支持
3. **性能优化**: 按需导入可以减少打包体积
4. **维护性**: 模块化设计使得错误码的维护更加便捷

## 常见问题

### Q: 如何选择合适的错误码？
A: 根据错误的业务领域选择对应的模块，如用户相关错误使用UserErrorCode，参数验证错误使用ValidationErrorCode。

### Q: 可以自定义错误消息吗？
A: 可以，在调用ResponseUtil.error时传入自定义消息，会覆盖默认消息。

### Q: 如何处理多语言错误消息？
A: 可以扩展BusinessCode类，根据请求的语言设置返回对应的错误消息。

### Q: 新增错误码时需要注意什么？
A: 确保错误码在对应模块的范围内，避免与现有错误码冲突，并更新相关的消息和HTTP状态码映射。