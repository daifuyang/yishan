# 移山通用管理系统 (Yishan) - LLM 开发规范

## 项目概述

移山通用管理系统是一个基于现代技术栈的快速开发管理系统 monorepo 项目，专为 zerocmf.com 打造的通用管理解决方案。

## 项目架构

### Monorepo 结构
```
yishan/
├── apps/                     # 应用层
│   ├── yishan-admin/        # 管理后台应用 (Ant Design Pro)
│   ├── yishan-api/          # API 服务 (Fastify)
│   └── yishan-docs/         # 项目文档站点 (Docusaurus)
├── packages/                 # 共享包和组件库
│   └── shadcn/              # shadcn/ui 组件库
├── package.json              # 根项目配置
├── pnpm-workspace.yaml       # pnpm 工作空间配置
└── README.md                # 项目说明文档
```

## API 服务开发规范 (yishan-api)

### 技术栈
- **框架**: Fastify 5.x
- **语言**: TypeScript 5.8+
- **数据库**: MySQL 2 + Knex.js
- **认证**: JWT (@fastify/jwt)
- **文档**: Swagger (@fastify/swagger)
- **构建**: TypeScript Compiler

### 项目结构
```
src/
├── plugins/
│   ├── external/          # 外部插件 (安全、CORS、JWT等)
│   └── app/              # 应用插件 (业务逻辑)
├── routes/               # 路由定义
│   └── api/
│       └── v1/
│           ├── admin/    # 管理员路由 (需要认证)
│           │   ├── users/
│           │   │   └── index.ts  # 用户管理路由 (/api/v1/admin/users)
│           │   ├── index.ts      # 管理员首页路由 (/api/v1/admin)
│           │   └── autohooks.ts  # 管理员路由钩子 (认证等)
│           └── auth.ts   # 认证路由
├── services/             # 业务服务层
├── domain/               # 领域模型和DTO
├── utils/                # 工具函数
├── constants/            # 常量定义
└── app.ts               # 应用入口点
```

### 开发规范

#### 1. 路由组织
- 使用 Fastify autoload 自动注册路由
- 路由文件导出默认异步函数: `export default async function routeName(fastify: FastifyInstance)`
- 管理员路由放在 `/api/v1/admin/` 目录下
- 公共路由放在 `/api/v1/` 目录下

**重要路由规范**:
- 对于需要子路径的路由（如 `/api/v1/admin/users`），应创建对应的目录结构
- 例如：`/api/v1/admin/users` 路由应放在 `routes/api/v1/admin/users/index.ts`
- 在路由文件中，路径应使用相对路径（如 `'/'` 而不是 `/users`）
- fastifyAutoload 会根据文件路径自动生成完整的路由路径
- 使用 `autohooks.ts` 文件可以为目录下的所有路由添加通用的钩子函数（遵循 Fastify autoload 官方命名约定）
- `autohooks.ts` 中的钩子会自动应用到同级目录及所有子目录的路由上

#### 2. 认证机制
- 使用 JWT 进行身份认证
- 认证装饰器: `fastify.authenticate`
- 管理员路由通过 `autohooks.ts` 自动应用认证，无需在每个路由中手动添加
- 对于需要特殊认证处理的路由，可以使用 `preHandler: fastify.authenticate`
- JWT 配置在 `plugins/external/jwt-auth.ts`

**认证钩子最佳实践**:
- 使用 `autohooks.ts`（遵循 Fastify autoload 官方约定）
- `autohooks.ts` 文件会自动被 Fastify autoload 识别并应用到所有子路由
- 钩子文件示例：
```typescript
import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify'

export default async function (fastify: FastifyInstance) {
  fastify.addHook('preHandler', async (request: FastifyRequest, reply: FastifyReply) => {
    return fastify.authenticate(request, reply)
  })
}
```

#### 3. 响应格式
统一响应格式 (通过 response-formatter 插件):
```typescript
// 成功响应
{
  code: number,      // 业务状态码
  message: string,   // 响应消息
  data: any         // 响应数据
}

// 错误响应
{
  code: number,      // 业务状态码
  message: string,   // 错误消息
  data: null
}
```

#### 4. 业务状态码
使用5位数字业务状态码 (定义在 `constants/business-code.ts`):
- 第1位: 业务模块标识 (1-系统, 2-用户, 3-订单, 4-商品, 5-支付, 6-分页, 9-通用)
- 第2-3位: 业务功能标识
- 第4-5位: 具体状态标识
- 20000-29999: 成功状态
- 40000-49999: 客户端错误
- 50000-59999: 服务器错误

#### 4.1 API响应示例值规范
在 Swagger/OpenAPI 文档的响应模式定义中，`code` 字段的 `example` 值必须使用5位数字的业务码，而不是HTTP状态码：

**✅ 正确示例**:
```typescript
{
  "200": {
    "type": "object",
    "properties": {
      "code": { "type": "number", "example": 20000 },  // 使用业务码
      "message": { "type": "string", "example": "操作成功" }
    }
  },
  "404": {
    "type": "object",
    "properties": {
      "code": { "type": "number", "example": 40010 },  // 使用业务码
      "message": { "type": "string", "example": "用户不存在" }
    }
  }
}
```

**❌ 错误示例**:
```typescript
{
  "200": {
    "type": "object",
    "properties": {
      "code": { "type": "number", "example": 200 },    // 错误：使用HTTP状态码
      "message": { "type": "string", "example": "操作成功" }
    }
  }
}
```

**常用业务码示例值对照表**:
- HTTP 200 → 业务码 20000 (通用成功)
- HTTP 201 → 业务码 20001 (创建成功)
- HTTP 400 → 业务码 40001 (参数错误)
- HTTP 401 → 业务码 40003 (未授权)
- HTTP 403 → 业务码 40004 (权限不足)
- HTTP 404 → 业务码 40010 (资源不存在)
- HTTP 500 → 业务码 50000 (服务器错误)

#### 4.2 分页查询状态码
分页查询使用统一的业务状态码规范：

- **成功状态码**: 使用 20000 (SUCCESS) - 操作成功
- **客户端错误**: 使用 40010 (INVALID_PARAMETER) - 参数无效
- **服务器错误**: 使用 50000 (INTERNAL_ERROR) - 内部服务器错误

参数验证错误在 error.validation 字段中详细说明：
- page: 页码必须大于等于1
- pageSize: 页大小必须在1-100之间
- sortBy: 排序字段不合法
- sortOrder: 排序方向必须是asc或desc

#### 5. Schema 定义
- 所有路由必须定义完整的 Fastify Schema
- 包含 tags, summary, description, operationId
- 定义完整的 request body 和 response schema
- 使用 TypeScript 类型约束

#### 5.1 Schema 命名规范
- **必须**与数据库表名保持一致（包括前缀）
- **必须**包含业务模块前缀
- **必须**添加功能类型后缀
- 使用小驼峰命名法（camelCase）

**命名格式**:
```
[业务前缀][功能名称][类型后缀]
```

**示例**:
- `sysUserSchema` - 对应 sys_user 表
- `sysUserTokenResponseSchema` - 系统用户token响应
- `sysUserLoginRequestSchema` - 系统用户登录请求
- `sysUserRefreshTokenRequestSchema` - 系统用户刷新token请求

**文件命名**:
- 使用 `kebab-case` 命名法
- 格式：`[模块名].schema.ts`
- 示例：`auth.schema.ts`、`user.schema.ts`

**$id 命名**:
- 必须与导出名称保持一致
- 使用简洁的命名，不包含文件路径
- 示例：`sysUser`、`sysUserTokenResponse`

**最佳实践**:
1. **集中注册**: 所有schema统一在`plugins/external/schemas.ts`中注册
2. **职责分离**: 路由文件专注业务逻辑，schema管理由插件负责
3. **路径规范**: 使用正确的相对路径（如`../../schemas/auth.schema.js`）
4. **插件包装**: 使用`fastify-plugin`包装插件，确保正确元数据

**新增模块步骤**:
1. 在`schemas/`目录创建新的schema文件
2. 在`plugins/external/schemas.ts`中导入并注册新schema
3. 在路由文件中直接使用$ref引用，无需重复注册

#### 6. 错误处理
- 使用 Fastify 内置错误处理机制
- 自定义错误处理器在 `app.ts` 中定义
- 404 错误包含速率限制保护

#### 7. 插件开发
- 外部插件放在 `plugins/external/`
- 应用插件放在 `plugins/app/`
- 使用 `fastify-plugin` 包装
- 插件必须声明名称和版本兼容性

#### 8. 数据库操作
- 使用 Knex.js 作为查询构建器
- 数据库连接配置在 `plugins/external/knex.ts`
- 使用 Service 层封装数据库操作
- 支持事务处理

#### 8.1 分页查询规范
基于企业级标准的统一分页规范，详细规范见 `apps/yishan-api/docs/PAGINATION_SPECIFICATION.md`

- **标准查询参数**:
  ```typescript
  interface PaginationQuery {
    page?: number;        // 页码，默认1，必须≥1
    pageSize?: number;    // 每页条数，默认10，范围1-100
    sortBy?: string;      // 排序字段，默认id，需验证字段合法性
    sortOrder?: 'asc' | 'desc'; // 排序方向，默认desc
    search?: string;      // 搜索关键词，最大长度255，自动trim
  }
  ```

- **标准响应格式**:
  ```typescript
  interface PaginationResponse<T> {
    code: number;           // 业务状态码 (20000-成功)
    message: string;        // 响应消息
    data: {
      list: T[];            // 数据列表
      pagination: {
        page: number;       // 当前页码
        pageSize: number;   // 每页条数
        total: number;      // 总记录数
        totalPages: number; // 总页数
      }
    }
  }
  ```

- **客户端分页状态判断**:
  - 是否有下一页：`page < totalPages`
  - 是否有上一页：`page > 1`
  - 是否为空结果：`total === 0`
  - 是否为最后一页：`page === totalPages`

- **Knex.js 数据库查询规范**:
  ```typescript
  // 1. 并行查询总数和数据，避免GROUP BY冲突
  const [countResult, data] = await Promise.all([
    knex('table_name')
      .whereNull('deleted_at')
      .modify(qb => applyFilters(qb, query))
      .count('* as count')
      .first(),
    
    knex('table_name')
      .select(['id', 'name', 'created_at'])
      .whereNull('deleted_at')
      .modify(qb => applyFilters(qb, query))
      .orderBy(sortBy, sortOrder)
      .limit(pageSize)
      .offset((page - 1) * pageSize)
  ]);
  
  // 2. 事务支持
  await knex.transaction(async (trx) => {
    // 在事务中执行分页查询
  });
  ```

- **性能优化最佳实践**:
  - 使用索引优化排序和筛选字段
  - 避免在大数据集上使用 `LIKE '%keyword%'`
  - 实现 Redis 缓存机制（列表缓存300秒）
  - 参数验证和边界检查
  - 使用 `Promise.all` 并行查询提升性能

#### 8.2 角色管理数据库规范 (RBAC)
基于简化RBAC (Role-Based Access Control) 的角色权限管理系统规范：

**核心表结构**:
1. **sys_role (角色表)**:
   - 基础字段：id, role_name, role_desc, is_system, status
   - 审计字段：creator_id, created_at, updater_id, updated_at, deleted_at
   - is_system: 标识是否为系统默认角色 (0-否, 1-是)
   - 简洁设计，只保留必要字段

2. **sys_user_role (用户角色关联表)**:
   - 用户与角色的多对多关系
   - 基础字段：user_id, role_id, status
   - 审计字段支持

3. **sys_permission (权限表)**:
   - 树形结构权限管理 (parent_id)
   - 支持菜单、按钮、API权限 (permission_type: 1-菜单, 2-按钮, 3-接口)
   - 资源URL和HTTP方法映射
   - 基础字段：permission_name, permission_desc, resource_url, resource_method

4. **sys_role_permission (角色权限关联表)**:
   - 角色与权限的多对多关系
   - 基础字段：role_id, permission_id, status
   - 审计字段支持

**设计原则**:
- 0/1 布尔值规范 (0-否/禁用, 1-是/启用)
- 软删除机制 (deleted_at)
- 审计字段 (creator_id, created_at, updater_id, updated_at)
- 外键约束和级联操作
- 简化索引优化查询性能

**用户友好性设计**:
- role_name: 用户友好的角色名称
- role_desc: 可选的角色描述
- is_system: 系统角色保护机制，防止误删系统默认角色
- 去除复杂的编码和分类字段
- 专注于核心功能：角色名称 + 描述 + 权限配置

**迁移文件规范**:
- 使用 003-006 序号的迁移文件
- 完整的 do/undo 操作对
- 外键约束管理 (FOREIGN_KEY_CHECKS)
- 预置系统默认数据

#### 9. 环境配置
- 使用 `@fastify/env` 管理环境变量
- 配置文件: `.env`
- 必需的环境变量在插件中声明

#### 10. 开发命令
```bash
# 开发模式 (热重载)
pnpm run dev

# 构建 TypeScript
pnpm run build:ts

# 生产模式启动
pnpm start

# 数据库操作
pnpm run db:create    # 创建数据库
pnpm run db:migrate   # 运行迁移
pnpm run db:seed      # 填充种子数据
pnpm run db:reset     # 重置数据库
```

#### 10.1 相关文档
- `apps/yishan-api/docs/PAGINATION_SPECIFICATION.md` - 详细分页规范文档
- `apps/yishan-api/docs/RESPONSE_STATUS_CODE_SPECIFICATION.md` - 响应状态码规范
- `apps/yishan-api/docs/PROJECT_SPECIFICATION.md` - 项目整体规范

#### 10.2 最近更新 (2025年10月10日)
- ✅ 更新分页查询规范，符合大厂企业级标准
- ✅ 基于 Knex.js 的完整分页实现规范和最佳实践
- ✅ 统一响应格式（包含完整的响应元数据）
- ✅ 简化分页响应格式（移除hasNext/hasPrev字段，由客户端计算）
- ✅ 统一命名规范（数据列表使用list，每页条数使用pageSize）
- ✅ 创建专门的分页规范文档 `PAGINATION_SPECIFICATION.md`
- ✅ 优化数据库查询规范，避免GROUP BY冲突
- ✅ 添加客户端分页状态判断逻辑
- ✅ 统一状态码规范（使用通用业务状态码20000，移除分页专用状态码）
- ✅ 添加性能优化和缓存策略指导
- ✅ 完善事务支持和错误处理机制
- ✅ **新增角色管理数据库规范 (RBAC)**
  - 企业级角色权限管理系统设计
  - 四核心表结构：sys_role, sys_user_role, sys_permission, sys_role_permission
  - 用户友好性设计：role_name + role_display_name + role_code
  - 系统内置角色保护机制 (is_system)
  - 数据权限范围控制和时间控制
  - 完整的迁移文件规范 (003-006)

## 前端开发规范 (yishan-admin)

### 技术栈
- **框架**: Ant Design Pro (基于 UmiJS)
- **UI库**: Ant Design
- **语言**: TypeScript
- **构建**: UmiJS Max

### 开发规范
- 遵循 Ant Design Pro 官方规范
- 使用 TypeScript 严格模式
- 组件化开发，复用性优先
- 响应式设计，支持多端适配

## 文档规范 (yishan-docs)

### 技术栈
- **框架**: Docusaurus 3.8+
- **语言**: TypeScript + MDX

### 内容组织
- API 文档自动生成
- 开发指南和最佳实践
- 组件使用示例
- 更新日志维护

## 通用开发规范

### 1. 代码风格
- 使用 TypeScript 严格模式
- 遵循 ESLint 和 Prettier 配置
- 使用 Biome 进行代码检查
- 统一使用 pnpm 作为包管理器

### 2. Git 工作流
- 使用 Husky + lint-staged 进行提交前检查
- 遵循 Conventional Commits 规范
- 功能分支开发，主分支保护

### 3. 版本管理
- 使用语义化版本控制 (SemVer)
- 维护详细的 CHANGELOG
- 定期发布稳定版本

### 4. 测试策略
- 单元测试覆盖核心业务逻辑
- API 接口测试
- E2E 测试覆盖关键用户流程

### 5. 部署规范
- 支持 Docker 容器化部署
- 推荐 Vercel 部署前端应用
- 环境变量管理和配置分离

## 最佳实践

### 1. 性能优化
- API 响应缓存策略
- 数据库查询优化
- 前端资源懒加载
- CDN 静态资源分发

### 2. 安全规范
- JWT Token 安全管理
- API 速率限制
- 输入验证和 SQL 注入防护
- HTTPS 强制使用

### 3. 监控和日志
- 结构化日志记录
- 错误监控和告警
- 性能指标收集
- 用户行为分析

### 4. 可维护性
- 模块化架构设计
- 清晰的代码注释
- 完善的类型定义
- 自动化测试覆盖

## 开发工具推荐

### IDE 配置
- VS Code + 相关插件
- TypeScript 严格模式
- ESLint + Prettier 集成
- Git 集成和可视化

### 调试工具
- Fastify 内置日志
- Swagger UI API 调试
- Chrome DevTools
- Postman/Insomnia API 测试

### 路由调试
- 使用 `fastify.log.info()` 记录路由注册信息
- 检查 fastifyAutoload 的目录结构映射
- 验证路由路径与文件路径的对应关系
- 使用 Swagger 文档查看已注册的路由
- 验证 `autohooks.ts` 文件是否被正确识别和加载
- 测试认证钩子是否正确应用到所有子路由

**常见问题排查**:
- 如果钩子未生效，检查文件名是否为 `autohooks.ts`（不是 `_hooks.ts`）
- 确认 `app.ts` 中 fastifyAutoload 配置了 `autoHooks: true` 和 `cascadeHooks: true`
- 使用无认证请求测试路由，应返回 40001 错误码表示认证生效

## 最近更新

**2025年10月10日**:
- 简化角色管理数据库设计，移除过度复杂的字段
- 角色表只保留：角色名称、描述、状态和基础审计字段
- 权限表简化为：菜单、按钮、接口三种类型
- 关联表结构优化，去除复杂的时间控制和分类字段
- 更新迁移文件 003-006，专注核心RBAC功能

---

**注意**: 本规范文档应随项目发展持续更新，确保团队开发的一致性和代码质量。